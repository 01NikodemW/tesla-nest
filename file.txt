filepath: src/database/seed.service.ts
file content:
import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Vehicle } from '../vehicles/entities/vehicle.entity';

@Injectable()
export class SeedService {
  private readonly logger = new Logger(SeedService.name);

  constructor(
    @InjectRepository(Vehicle)
    private readonly vehicleRepository: Repository<Vehicle>,
  ) {}

  async seedVehicles(): Promise<void> {
    const count = await this.vehicleRepository.count();

    if (count > 0) {
      this.logger.log(
        'Seeding skipped. Vehicles already exist in the database.',
      );
      return;
    }

    const vehicles = [
      { make: 'Toyota', model: 'Corolla', year: 2022, rentalPricePerDay: 50 },
      { make: 'Honda', model: 'Civic', year: 2021, rentalPricePerDay: 45 },
      { make: 'Ford', model: 'Focus', year: 2023, rentalPricePerDay: 55 },
      { make: 'Tesla', model: 'Model 3', year: 2022, rentalPricePerDay: 80 },
      { make: 'Tesla', model: 'Model S', year: 2022, rentalPricePerDay: 80 },
    ];

    this.logger.log('Seeding vehicles...');
    await this.vehicleRepository.save(vehicles);
    this.logger.log('Seeding completed.');
  }
}


filepath: src/database/seed.module.ts
file content:
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Vehicle } from '../vehicles/entities/vehicle.entity';
import { SeedService } from './seed.service';

@Module({
  imports: [TypeOrmModule.forFeature([Vehicle])],
  providers: [SeedService],
  exports: [SeedService],
})
export class SeedModule {}


filepath: src/payments/dto/create-payment-intent.dto.ts
file content:
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsInt, IsString, Min } from 'class-validator';

export class CreatePaymentIntentDto {
  @ApiProperty({ example: 10, description: 'Amount of payment' })
  @IsInt()
  @Min(1, { message: 'Amount must be greater than 0' })
  amount: number;

  @ApiProperty({ example: 'usd', description: 'Currency of payment' })
  @IsString()
  currency: string;

  @ApiProperty({ example: 'test@test.com', description: 'User email' })
  @IsEmail()
  email: string;
}


filepath: src/payments/filters/stripe-exception.filter.ts
file content:
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  Logger,
} from '@nestjs/common';
import { Response } from 'express';

@Catch(HttpException)
export class StripeExceptionFilter implements ExceptionFilter {
  private readonly logger = new Logger(StripeExceptionFilter.name);

  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();

    const status = exception.getStatus();
    const message = exception.getResponse();

    this.logger.error(`Stripe Error: ${JSON.stringify(message)}`);

    response.status(status).json({
      statusCode: status,
      error: 'Stripe Error',
      message,
    });
  }
}


filepath: src/payments/stripe.service.ts
file content:
import { Injectable, Inject } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import Stripe from 'stripe';
import { CreatePaymentIntentDto } from './dto/create-payment-intent.dto';

@Injectable()
export class StripeService {
  constructor(
    @Inject('STRIPE_CLIENT') private readonly stripe: Stripe,
    private readonly configService: ConfigService,
  ) {}

  async createPaymentIntent(createPaymentIntentDto: CreatePaymentIntentDto) {
    const { amount, currency, email } = createPaymentIntentDto;

    // Convert amount to the smallest unit (Stripe expects it in cents)
    const amountInSmallestUnit = this.convertAmountToSmallestUnit(
      amount,
      currency,
    );

    return await this.stripe.paymentIntents.create({
      amount: amountInSmallestUnit,
      currency,
      receipt_email: email,
    });
  }

  private convertAmountToSmallestUnit(
    amount: number,
    currency: string,
  ): number {
    const currenciesWithCents = ['usd', 'eur', 'gbp', 'pln', 'cad']; // Add more if needed

    if (currenciesWithCents.includes(currency.toLowerCase())) {
      return Math.round(amount * 100);
    }

    return Math.round(amount); // For currencies that don't use subunits (like JPY)
  }

  async processWebhook(req: any, signature: string) {
    const endpointSecret = this.configService.get<string>(
      'STRIPE_WEBHOOK_SECRET',
    );

    let event;
    try {
      event = this.stripe.webhooks.constructEvent(
        req.rawBody,
        signature,
        endpointSecret,
      );
    } catch (err) {
      throw new Error(`Webhook signature verification failed: ${err.message}`);
    }

    switch (event.type) {
      case 'payment_intent.succeeded':
        console.log('âœ… Payment confirmed:', event.data.object);
        // await this.updatePaymentStatus(event.data.object, 'succeeded');
        break;
      case 'payment_intent.payment_failed':
        console.log('âŒ Payment failed:', event.data.object);
        // await this.updatePaymentStatus(event.data.object, 'failed');
        break;
      default:
        console.log('Unhandled event type:', event.type);
    }
  }

  // private async updatePaymentStatus(paymentIntent: any, status: string) {
  //   const reservationId = paymentIntent.metadata?.reservationId;
  //   if (reservationId) {
  //     await this.reservationRepository.update(reservationId, {
  //       paymentStatus: status,
  //     });
  //   }
  // }
}


filepath: src/payments/stripe.module.ts
file content:
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { StripeService } from './stripe.service';
import { StripeController } from './stripe.controller';
import { StripeWebhookController } from './webhook.controller';

@Module({
  controllers: [StripeController, StripeWebhookController], // Register webhook controller
  providers: [
    {
      provide: 'STRIPE_CLIENT',
      useFactory: (configService: ConfigService) => {
        return require('stripe')(
          configService.get<string>('STRIPE_SECRET_KEY'),
        );
      },
      inject: [ConfigService],
    },
    StripeService,
  ],
})
export class StripeModule {}


filepath: src/payments/webhook.controller.ts
file content:
import { Controller, Post, Req, Res, Headers } from '@nestjs/common';
import { StripeService } from './stripe.service';
import { Response, Request } from 'express';

@Controller('webhooks')
export class StripeWebhookController {
  constructor(private readonly stripeService: StripeService) {}

  @Post('stripe')
  async handleWebhook(
    @Req() req: Request,
    @Res() res: Response,
    @Headers('stripe-signature') signature: string,
  ) {
    try {
      await this.stripeService.processWebhook(req, signature);
      res.status(200).send('Webhook received');
    } catch (err) {
      res.status(400).send(`Webhook error: ${err.message}`);
    }
  }
}


filepath: src/payments/stripe.controller.ts
file content:
import { Controller, Post, Body, UseFilters } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { StripeService } from './stripe.service';
import { StripeExceptionFilter } from './filters/stripe-exception.filter';
import { CreatePaymentIntentDto } from './dto/create-payment-intent.dto';

@ApiTags('Payments')
@UseFilters(StripeExceptionFilter)
@Controller('payments')
export class StripeController {
  constructor(private readonly stripeService: StripeService) {}

  @Post('create-intent')
  @ApiOperation({ summary: 'Tworzy PaymentIntent w Stripe' })
  @ApiResponse({
    status: 201,
    description: 'Zwraca client_secret do finalizacji pÅ‚atnoÅ›ci',
  })
  async createPaymentIntent(
    @Body() createPaymentIntentDto: CreatePaymentIntentDto,
  ) {
    const paymentIntent = await this.stripeService.createPaymentIntent(
      createPaymentIntentDto,
    );
    return { clientSecret: paymentIntent.client_secret };
  }
}


filepath: src/logger/logger.service.ts
file content:
import { Injectable } from '@nestjs/common';
import * as winston from 'winston';
import 'winston-daily-rotate-file';
import * as path from 'path';

@Injectable()
export class LoggerService {
  private logger: winston.Logger;

  constructor() {
    const logDirectory = path.join(__dirname, '../../logs');

    this.logger = winston.createLogger({
      level: 'info',
      format: winston.format.combine(
        winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
        winston.format.printf(
          ({ timestamp, level, message }) =>
            `${timestamp} [${level.toUpperCase()}]: ${message}`,
        ),
      ),
      transports: [
        // âœ… Console logging
        new winston.transports.Console(),

        // âœ… File logging with daily rotation
        new winston.transports.DailyRotateFile({
          filename: `${logDirectory}/%DATE%/app.log`,
          datePattern: 'YYYY-MM-DD',
          maxFiles: '30d',
          zippedArchive: true,
          level: 'info', // âœ… Ensure this is correct
        }),
      ],
    });

    this.logger.info('LoggerService initialized'); // âœ… Test log when service starts
  }

  log(message: string) {
    this.logger.info(message);
  }

  warn(message: string) {
    this.logger.warn(message);
  }

  error(message: string) {
    this.logger.error(message);
  }
}


filepath: src/logger/logger.module.ts
file content:
import { Module, Global } from '@nestjs/common';
import { LoggerService } from './logger.service';

@Global()
@Module({
  providers: [LoggerService],
  exports: [LoggerService],
})
export class LoggerModule {}


filepath: src/main.ts
file content:
import {
  ValidationPipe,
  ClassSerializerInterceptor,
  Logger,
} from '@nestjs/common';
import { NestFactory, Reflector } from '@nestjs/core';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { AppModule } from './app.module';

async function bootstrap() {
  const logger = new Logger('Bootstrap');
  const app = await NestFactory.create(AppModule);

  // âœ… Enable CORS (for frontend API access)
  app.enableCors();

  // âœ… Global Validation Pipes
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true, // Remove extra fields automatically
      forbidNonWhitelisted: true, // Throw error for extra fields
      transform: true, // Automatically transform types (DTOs)
      transformOptions: {
        enableImplicitConversion: true,
      },
    }),
  );

  // âœ… Global Serialization Interceptor (Hides @Exclude() fields like password)
  app.useGlobalInterceptors(new ClassSerializerInterceptor(app.get(Reflector)));

  // âœ… Enable API Versioning (Optional)
  app.enableVersioning();

  // âœ… Swagger API Configuration
  const config = new DocumentBuilder()
    .setTitle('NestJs Masterclass - Blog app API')
    .setDescription('Use the base API URL as http://localhost:3000')
    .setVersion('1.0')
    .addServer('http://localhost:3000')
    .addBearerAuth(
      {
        type: 'http',
        scheme: 'bearer',
        bearerFormat: 'JWT',
        in: 'header',
      },
      'access-token',
    )
    .build();

  // âœ… Setup Swagger Module
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api', app, document);

  // âœ… Start the server
  await app.listen(3000);

  logger.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();


filepath: src/config/azure.config.ts
file content:
import { registerAs } from '@nestjs/config';

export default registerAs('azure', () => ({
  blobStorageConnectionString: process.env.BLOB_STORAGE_CONNECTION_STRING,
  blobStorageVehicleImagesContainerName:
    process.env.BLOB_STORAGE_VEHICLE_IMAGES_CONTAINER_NAME,
}));


filepath: src/config/stripe.config.ts
file content:
import { registerAs } from '@nestjs/config';

export default registerAs('stripe', () => ({
  stripePublishableKey: process.env.STRIPE_PUBLISHABLE_KEY,
  stripeSecretKey: process.env.STRIPE_SECRET_KEY,
}));


filepath: src/config/database.config.ts
file content:
import { registerAs } from '@nestjs/config';

export default registerAs('database', () => ({
  host: process.env.DATABASE_HOST || 'localhost',
  port: parseInt(process.env.DATABASE_PORT) || 5432,
  user: process.env.DATABASE_USER,
  password: process.env.DATABASE_PASSWORD,
  name: process.env.DATABASE_NAME,
  synchronize: process.env.DATABASE_SYNC === 'true' ? true : false,
  autoLoadEntities: process.env.DATABASE_AUTOLOAD === 'true' ? true : false,
}));


filepath: src/config/enviroment.validation.ts
file content:
import * as Joi from 'joi';

export default Joi.object({
  NODE_ENV: Joi.string()
    .valid('development', 'production', 'test', 'provision')
    .default('development'),
  DATABASE_PORT: Joi.number().port().default(5432),
  DATABASE_PASSWORD: Joi.string().required(),
  DATABASE_HOST: Joi.string().required(),
  DATABASE_NAME: Joi.string().required(),
  DATABASE_USER: Joi.string().required(),
  JWT_SECRET: Joi.string().required(),
});


filepath: src/config/jwt.config.ts
file content:
import { registerAs } from '@nestjs/config';

export default registerAs('jwtConfig', () => ({
  jwtSecret: process.env.JWT_SECRET,
}));


filepath: src/auth/dto/login.dto.ts
file content:
import { IsString, IsEmail, MinLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class LoginDto {
  @ApiProperty({ example: 'email@gmail.com', description: 'User email' })
  @IsEmail()
  email: string;

  @ApiProperty({ example: '@Haslo123', description: 'User password', minLength: 6 })
  @IsString()
  @MinLength(6)
  password: string;
}


filepath: src/auth/dto/register.dto.ts
file content:
import { IsString, IsEmail, MinLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class RegisterDto {
  @ApiProperty({ example: 'email@gmail.com', description: 'User email' })
  @IsEmail()
  email: string;

  @ApiProperty({ example: '@Haslo123', description: 'User password', minLength: 6 })
  @IsString()
  @MinLength(6)
  password: string;
}


filepath: src/auth/auth.controller.ts
file content:
import { Controller, Post, Body, Request, UseGuards } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBody } from '@nestjs/swagger';
import { AuthService } from './auth.service';
import { LocalAuthGuard } from './guards/local-auth.guard';
import { LoginDto } from './dto/login.dto';
import { RegisterDto } from './dto/register.dto';

@ApiTags('Auth')
@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @UseGuards(LocalAuthGuard)
  @Post('login')
  @ApiOperation({ summary: 'Log in to the application' })
  @ApiResponse({
    status: 200,
    description: 'Login successful. Returns a JWT token.',
  })
  @ApiResponse({ status: 401, description: 'Invalid credentials.' })
  @ApiBody({ type: LoginDto })
  async login(@Request() req) {
    return this.authService.login(req.user);
  }

  @Post('register')
  @ApiOperation({ summary: 'Register a new user' })
  @ApiResponse({ status: 201, description: 'User registered successfully.' })
  @ApiResponse({ status: 409, description: 'User already exists.' })
  @ApiBody({ type: RegisterDto })
  async register(@Body() registerDto: RegisterDto) {
    return this.authService.register(registerDto.email, registerDto.password);
  }
}


filepath: src/auth/auth.service.ts
file content:
import {
  Injectable,
  ConflictException,
  UnauthorizedException,
} from '@nestjs/common';
import { UsersService } from '../users/users.service';
import { JwtService } from '@nestjs/jwt';
import { User } from '../users/entities/user.entity';

@Injectable()
export class AuthService {
  constructor(
    private readonly usersService: UsersService,
    private readonly jwtService: JwtService,
  ) {}

  async validateUser(email: string, password: string): Promise<User> {
    const user = await this.usersService.validateUser(email, password);
    if (!user) {
      throw new UnauthorizedException('Invalid email or password');
    }
    return user;
  }

  async login(user: User): Promise<{ access_token: string }> {
    const payload = { email: user.email, sub: user.id, roles: user.roles };
    return {
      access_token: this.jwtService.sign(payload),
    };
  }

  async register(email: string, password: string): Promise<User> {
    const existingUser = await this.usersService.findOne(email);
    if (existingUser) {
      throw new ConflictException('Email is already registered');
    }
    return this.usersService.create(email, password);
  }
}


filepath: src/auth/decorators/roles.decorator.ts
file content:
import { SetMetadata } from '@nestjs/common';
import { RoleEnum } from '../enum/role.enum';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: RoleEnum[]) => SetMetadata(ROLES_KEY, roles);


filepath: src/auth/strategies/jwt.strategy.ts
file content:
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get('JWT_SECRET'),
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, email: payload.email };
  }
}


filepath: src/auth/strategies/local.strategy.ts
file content:
import { Strategy } from 'passport-local';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { AuthService } from '../auth.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super({ usernameField: 'email' });
  }

  async validate(email: string, password: string): Promise<any> {
    const user = await this.authService.validateUser(email, password);
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }
    return user;
  }
}


filepath: src/auth/enum/role.enum.ts
file content:
export enum RoleEnum {
    USER = 'USER',
    ADMIN = 'ADMIN',
  }
  

filepath: src/auth/auth.module.ts
file content:
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { UsersModule } from '../users/users.module';
import { JwtStrategy } from './strategies/jwt.strategy';
import { PassportModule } from '@nestjs/passport';
import { LocalStrategy } from './strategies/local.strategy';
import { ConfigModule, ConfigService } from '@nestjs/config';

@Module({
  controllers: [AuthController],
  imports: [
    UsersModule,
    PassportModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get('JWT_SECRET'),
        signOptions: { expiresIn: '1h' },
      }),
    }),
  ],
  providers: [AuthService, LocalStrategy, JwtStrategy],
  exports: [AuthService, JwtModule],
})
export class AuthModule {}


filepath: src/auth/guards/roles.guard.ts
file content:
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { JwtService } from '@nestjs/jwt';
import { ROLES_KEY } from '../decorators/roles.decorator';
import { RoleEnum } from '../enum/role.enum';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private jwtService: JwtService,
  ) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<RoleEnum[]>(
      ROLES_KEY,
      [context.getHandler(), context.getClass()],
    );

    if (!requiredRoles) {
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const authHeader = request.headers.authorization;

    if (!authHeader) return false;

    const token = authHeader.split(' ')[1];
    if (!token) return false;

    try {
      const user = this.jwtService.verify(token);
      return requiredRoles.some((role) => user.roles?.includes(role));
    } catch (error) {
      return false;
    }
  }
}


filepath: src/auth/guards/jwt-auth.guard.ts
file content:
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}


filepath: src/auth/guards/local-auth.guard.ts
file content:
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {}


filepath: src/reservations/dto/update-reservation.dto.ts
file content:
import { PartialType } from '@nestjs/swagger';
import { CreateReservationDto } from './create-reservation.dto';

export class UpdateReservationDto extends PartialType(CreateReservationDto) {}


filepath: src/reservations/dto/create-reservation.dto.ts
file content:
import { IsInt, IsDateString } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateReservationDto {
  @ApiProperty({
    description: 'User ID who is making the reservation',
    example: 1,
  })
  @IsInt()
  userId: number;

  @ApiProperty({ description: 'Vehicle ID being reserved', example: 2 })
  @IsInt()
  vehicleId: number;

  @ApiProperty({ description: 'Rental start date', example: '2025-02-10' })
  @IsDateString()
  rentalDate: string;

  @ApiProperty({ description: 'Return date', example: '2025-02-15' })
  @IsDateString()
  returnDate: string;
}


filepath: src/reservations/reservations.service.ts
file content:
import {
  Injectable,
  NotFoundException,
  BadRequestException,
  Inject,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Between, LessThanOrEqual } from 'typeorm';
import { Reservation, ReservationStatus } from './entities/reservation.entity';
import { CreateReservationDto } from './dto/create-reservation.dto';
import { UpdateReservationDto } from './dto/update-reservation.dto';
import { Vehicle } from '../vehicles/entities/vehicle.entity';
import { User } from '../users/entities/user.entity';
import * as dayjs from 'dayjs';
import { PaginationDto } from 'src/common/pagination/pagination.dto';
import { PaginationService } from 'src/common/pagination/pagination.service';
import { LoggerService } from 'src/logger/logger.service';
import { ReservationConflictException } from 'src/exceptions/reservation-conflict.exception';

@Injectable()
export class ReservationsService {
  constructor(
    @InjectRepository(Reservation)
    private readonly reservationRepository: Repository<Reservation>,
    @InjectRepository(Vehicle)
    private readonly vehicleRepository: Repository<Vehicle>,
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    private readonly paginationService: PaginationService,
    private readonly loggerService: LoggerService,
  ) {}

  async create(
    createReservationDto: CreateReservationDto,
  ): Promise<Reservation> {
    this.loggerService.log(
      `Creating reservation: ${JSON.stringify(createReservationDto)}`,
    );

    const { userId, vehicleId, rentalDate, returnDate } = createReservationDto;

    const user = await this.userRepository.findOne({ where: { id: userId } });
    if (!user) {
      this.loggerService.warn(`User with ID ${userId} not found`);
      throw new NotFoundException('User not found');
    }

    const vehicle = await this.vehicleRepository.findOne({
      where: { id: vehicleId },
    });
    if (!vehicle) {
      this.loggerService.warn(`Vehicle with ID ${vehicleId} not found`);
      throw new NotFoundException('Vehicle not found');
    }

    if (dayjs(rentalDate).isAfter(returnDate)) {
      this.loggerService.warn('Invalid rental period');
      throw new BadRequestException(
        'Rental date must be before or the same as return date',
      );
    }

    const existingReservation = await this.reservationRepository.findOne({
      where: {
        vehicle: { id: vehicleId },
        rentalDate: Between(rentalDate, returnDate),
      },
    });

    if (existingReservation) {
      this.loggerService.warn(
        `Vehicle ${vehicleId} is already reserved from ${existingReservation.rentalDate} to ${existingReservation.returnDate}`,
      );
      throw new ReservationConflictException(
        vehicleId,
        existingReservation.rentalDate,
        existingReservation.returnDate,
      );
    }

    const rentalDays = dayjs(returnDate).diff(rentalDate, 'day') + 1;
    const totalPrice = rentalDays * vehicle.rentalPricePerDay;

    const reservation = this.reservationRepository.create({
      user,
      vehicle,
      rentalDate,
      returnDate,
      totalPrice,
    });

    const savedReservation = await this.reservationRepository.save(reservation);
    this.loggerService.log(
      `Reservation created with ID: ${savedReservation.id}`,
    );

    return savedReservation;
  }

  async findAll(paginationDto: PaginationDto) {
    this.loggerService.log(
      `Fetching all reservations with pagination: ${JSON.stringify(paginationDto)}`,
    );

    const queryBuilder = this.reservationRepository
      .createQueryBuilder('reservation')
      .leftJoinAndSelect('reservation.user', 'user')
      .leftJoinAndSelect('reservation.vehicle', 'vehicle');

    const result = await this.paginationService.paginate(
      queryBuilder,
      paginationDto,
      'reservation',
    );

    this.loggerService.log(`Fetched ${result.data.length} reservations`);
    return result;
  }

  async findOne(id: number): Promise<Reservation> {
    this.loggerService.log(`Fetching reservation with ID: ${id}`);

    const reservation = await this.reservationRepository.findOne({
      where: { id },
      relations: ['user', 'vehicle'],
    });

    if (!reservation) {
      this.loggerService.warn(`Reservation with ID ${id} not found`);
      throw new NotFoundException('Reservation not found');
    }

    this.loggerService.log(`Reservation found: ${JSON.stringify(reservation)}`);
    return reservation;
  }

  async update(
    id: number,
    updateReservationDto: UpdateReservationDto,
  ): Promise<Reservation> {
    this.loggerService.log(
      `Updating reservation ID ${id} with data: ${JSON.stringify(updateReservationDto)}`,
    );

    const reservation = await this.findOne(id);
    const { rentalDate, returnDate, vehicleId } = updateReservationDto;

    if (rentalDate && returnDate) {
      if (dayjs(rentalDate).isAfter(returnDate)) {
        this.loggerService.warn('Invalid rental period');
        throw new BadRequestException(
          'Rental date must be before or the same as return date',
        );
      }

      const conflictingReservation = await this.reservationRepository.findOne({
        where: {
          vehicle: { id: vehicleId ?? reservation.vehicle.id },
          rentalDate: Between(rentalDate, returnDate),
        },
      });

      if (conflictingReservation && conflictingReservation.id !== id) {
        this.loggerService.warn(
          `Conflict: Vehicle ${vehicleId} is already reserved from ${conflictingReservation.rentalDate} to ${conflictingReservation.returnDate}`,
        );
        throw new ReservationConflictException(
          vehicleId,
          conflictingReservation.rentalDate,
          conflictingReservation.returnDate,
        );
      }

      const updatedRentalDays = dayjs(returnDate).diff(rentalDate, 'day') + 1;
      reservation.totalPrice =
        updatedRentalDays * reservation.vehicle.rentalPricePerDay;
    }

    Object.assign(reservation, updateReservationDto);
    const updatedReservation =
      await this.reservationRepository.save(reservation);

    this.loggerService.log(`Reservation ID ${id} updated successfully`);
    return updatedReservation;
  }

  async delete(id: number): Promise<void> {
    this.loggerService.warn(`Deleting reservation with ID: ${id}`);

    const reservation = await this.findOne(id);
    await this.reservationRepository.remove(reservation);

    this.loggerService.warn(`Reservation with ID ${id} deleted`);
  }

  async findExpiredReservations(): Promise<Reservation[]> {
    this.loggerService.log('Fetching expired reservations');
    return this.reservationRepository.find({
      where: {
        returnDate: LessThanOrEqual(new Date().toISOString().split('T')[0]),
        status: ReservationStatus.IN_PROGRESS,
      },
    });
  }

  async markAsExpired(ids: number[]): Promise<void> {
    if (ids.length > 0) {
      this.loggerService.log(
        `Marking reservations as expired: ${ids.join(', ')}`,
      );
      await this.reservationRepository.update(ids, {
        status: ReservationStatus.OVERDUE,
      });
    }
  }
}


filepath: src/reservations/reservations.module.ts
file content:
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ReservationsService } from './reservations.service';
import { ReservationsController } from './reservations.controller';
import { Reservation } from './entities/reservation.entity';
import { Vehicle } from '../vehicles/entities/vehicle.entity';
import { User } from '../users/entities/user.entity';
import { PaginationModule } from 'src/common/pagination/pagination.module';
import { ReservationCronService } from './reservation-cron.service';
import { LoggerModule } from 'src/logger/logger.module';

@Module({
  imports: [
    TypeOrmModule.forFeature([Reservation, Vehicle, User]),
    PaginationModule,
    LoggerModule,
  ],
  controllers: [ReservationsController],
  providers: [ReservationsService, ReservationCronService],
})
export class ReservationsModule {}


filepath: src/reservations/reservation-cron.service.ts
file content:
import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { ReservationsService } from './reservations.service';
import { ReservationStatus } from './entities/reservation.entity';

@Injectable()
export class ReservationCronService {
  private readonly logger = new Logger(ReservationCronService.name);

  constructor(private readonly reservationsService: ReservationsService) {}

  @Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT)
  async handleExpiredReservations() {
    this.logger.log('ðŸ” Checking for expired reservations...');

    const expiredReservations =
      await this.reservationsService.findExpiredReservations();
    const expiredIds = expiredReservations.map((reservation) => reservation.id);

    if (expiredIds.length > 0) {
      await this.reservationsService.markAsExpired(expiredIds);
      this.logger.log(
        `âœ… Marked ${expiredIds.length} reservations as EXPIRED.`,
      );
    } else {
      this.logger.log('âœ… No expired reservations found.');
    }
  }
}


filepath: src/reservations/reservations.controller.ts
file content:
import {
  Controller,
  Post,
  Get,
  Patch,
  Delete,
  Param,
  Body,
  Query,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { ReservationsService } from './reservations.service';
import { CreateReservationDto } from './dto/create-reservation.dto';
import { UpdateReservationDto } from './dto/update-reservation.dto';
import { PaginationDto } from 'src/common/pagination/pagination.dto';

@ApiTags('Reservations')
@Controller('reservations')
export class ReservationsController {
  constructor(private readonly reservationsService: ReservationsService) {}

  @Post()
  @ApiOperation({ summary: 'Create a new reservation' })
  @ApiResponse({
    status: 201,
    description: 'Reservation created successfully.',
  })
  async create(@Body() createReservationDto: CreateReservationDto) {
    return this.reservationsService.create(createReservationDto);
  }

  @Get()
  @ApiOperation({
    summary: 'Retrieve all reservations with pagination & sorting',
  })
  @ApiResponse({
    status: 200,
    description: 'List of paginated reservations retrieved.',
  })
  async findAll(@Query() paginationDto: PaginationDto) {
    return this.reservationsService.findAll(paginationDto);
  }

  @Get(':id')
  @ApiOperation({ summary: 'Retrieve a reservation by ID' })
  @ApiResponse({
    status: 200,
    description: 'Reservation retrieved successfully.',
  })
  async findOne(@Param('id') id: number) {
    return this.reservationsService.findOne(id);
  }

  @Patch(':id')
  @ApiOperation({ summary: 'Update a reservation by ID' })
  @ApiResponse({
    status: 200,
    description: 'Reservation updated successfully.',
  })
  async update(
    @Param('id') id: number,
    @Body() updateReservationDto: UpdateReservationDto,
  ) {
    return this.reservationsService.update(id, updateReservationDto);
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete a reservation by ID' })
  @ApiResponse({
    status: 200,
    description: 'Reservation deleted successfully.',
  })
  async remove(@Param('id') id: number) {
    return this.reservationsService.delete(id);
  }
}


filepath: src/reservations/entities/reservation.entity.ts
file content:
import { Entity, Column, ManyToOne } from 'typeorm';
import { ApiProperty } from '@nestjs/swagger';
import { User } from '../../users/entities/user.entity';
import { Vehicle } from '../../vehicles/entities/vehicle.entity';
import { BaseEntity } from 'src/common/entities/base.entity';

export enum ReservationStatus {
  IN_PROGRESS = 'IN_PROGRESS', // Car is currently rented
  COMPLETED = 'COMPLETED', // Car returned successfully
  OVERDUE = 'OVERDUE', // Car not returned on time
}

@Entity()
export class Reservation extends BaseEntity {
  @ManyToOne(() => User, (user) => user.id, { onDelete: 'CASCADE' })
  @ApiProperty({ description: 'User who made the reservation', example: 1 })
  user: User;

  @ManyToOne(() => Vehicle, (vehicle) => vehicle.id)
  @ApiProperty({ description: 'Vehicle reserved by the user', example: 2 })
  vehicle: Vehicle;

  @Column({ type: 'date' })
  @ApiProperty({ description: 'Rental start date', example: '2025-02-10' })
  rentalDate: string;

  @Column({ type: 'date' })
  @ApiProperty({ description: 'Return date', example: '2025-02-15' })
  returnDate: string;

  @Column()
  @ApiProperty({
    description: 'Total price of the reservation',
    example: 250.0,
  })
  totalPrice: number;

  @Column({
    type: 'enum',
    enum: ReservationStatus,
    default: ReservationStatus.IN_PROGRESS,
  })
  @ApiProperty({
    description: 'Current reservation status',
    example: ReservationStatus.IN_PROGRESS,
    enum: ReservationStatus,
  })
  status: ReservationStatus;
}


filepath: src/app.service.ts
file content:
import { Injectable, OnModuleInit } from '@nestjs/common';
import { SeedService } from './database/seed.service';

@Injectable()
export class AppService implements OnModuleInit {
  constructor(private readonly seedService: SeedService) {}

  getHello(): string {
    return 'Hello From NestJS!';
  }

  async onModuleInit() {
    await this.seedService.seedVehicles();
  }
}


filepath: src/admin/admin.controller.ts
file content:
import {
  Controller,
  Get,
  Param,
  Delete,
  UseGuards,
  Query,
  HttpCode,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { PaginationDto } from 'src/common/pagination/pagination.dto';
import { RolesGuard } from 'src/auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { RoleEnum } from '../auth/enum/role.enum';
import { UsersService } from 'src/users/users.service';
import { User } from 'src/users/entities/user.entity';

@ApiTags('Admin')
@Controller('admin')
@UseGuards(RolesGuard)
@Roles(RoleEnum.USER)
export class AdminController {
  constructor(private readonly userService: UsersService) {}

  @Get('users')
  @ApiOperation({ summary: 'Retrieve all users' })
  @ApiResponse({
    status: 200,
    description: 'List of users',
    type: [User],
  })
  @ApiResponse({ status: 403, description: 'Forbidden.' })
  async findAll(@Query() paginationDto: PaginationDto) {
    return this.userService.findAll(paginationDto);
  }

  @Delete('users/:id')
  @ApiOperation({ summary: 'Delete a user' })
  @HttpCode(204)
  @ApiResponse({ status: 204, description: 'User deleted successfully.' })
  @ApiResponse({ status: 404, description: 'User not found.' })
  async delete(@Param('id') id: number) {
    return this.userService.delete(id);
  }
}


filepath: src/admin/admin.module.ts
file content:
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AzureStorageModule } from '../azure-storage/azure-storage.module';
import { PaginationModule } from 'src/common/pagination/pagination.module';
import { LoggerModule } from 'src/logger/logger.module';
import { AuthModule } from 'src/auth/auth.module';
import { AdminController } from './admin.controller';
import { UsersModule } from 'src/users/users.module';

@Module({
  imports: [
    AzureStorageModule,
    PaginationModule,
    LoggerModule,
    AuthModule,
    UsersModule,
  ],
  controllers: [AdminController],
})
export class AdminModule {}


filepath: src/app.module.ts
file content:
import { MiddlewareConsumer, Module, NestModule } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';

import { VehiclesModule } from './vehicles/vehicles.module';
import { AuthModule } from './auth/auth.module';
import { UsersModule } from './users/users.module';
import { SeedModule } from './database/seed.module';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import databaseConfig from './config/database.config';
import enviromentValidation from './config/enviroment.validation';
import jwtConfig from './config/jwt.config';
import { ReservationsModule } from './reservations/reservations.module';
import { AzureStorageModule } from './azure-storage/azure-storage.module';
import azureConfig from './config/azure.config';
import stripeConfig from './config/stripe.config';
import { StripeModule } from './payments/stripe.module';
import { ScheduleModule } from '@nestjs/schedule';
import { LoggerModule } from './logger/logger.module';
import { ThrottlerGuard, ThrottlerModule } from '@nestjs/throttler';
import { APP_GUARD } from '@nestjs/core';
import { AdminModule } from './admin/admin.module';
import { LoggerMiddleware } from './common/middleware/logger.middleware';

const ENV = process.env.NODE_ENV;

@Module({
  imports: [
    LoggerModule,
    AdminModule,
    AzureStorageModule,
    VehiclesModule,
    AuthModule,
    ReservationsModule,
    UsersModule,
    SeedModule,
    StripeModule,
    ScheduleModule.forRoot(),
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: !ENV ? '.env' : `.env.${ENV}`,
      load: [databaseConfig, jwtConfig, azureConfig, stripeConfig],
      validationSchema: enviromentValidation,
    }),
    ThrottlerModule.forRoot([
      {
        ttl: 10000,
        limit: 50,
      },
    ]),
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        type: 'postgres',
        synchronize: configService.get('database.synchronize'),
        port: configService.get('database.port'),
        username: configService.get('database.user'),
        password: configService.get('database.password'),
        host: configService.get('database.host'),
        autoLoadEntities: configService.get('database.autoLoadEntities'),
        database: configService.get('database.name'),
      }),
    }),
  ],
  controllers: [AppController],
  providers: [
    AppService,
    {
      provide: APP_GUARD,
      useClass: ThrottlerGuard,
    },
  ],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      .forRoutes('cats');
  }
}


filepath: src/exceptions/reservation-conflict.exception.ts
file content:
import { BadRequestException } from '@nestjs/common';

export class ReservationConflictException extends BadRequestException {
  constructor(vehicleId: number, rentalDate: string, returnDate: string) {
    super(
      `This vehicle (ID: ${vehicleId}) is already reserved from ${rentalDate} to ${returnDate}`,
    );
  }
}


filepath: src/common/middleware/logger.middleware.ts
file content:
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    const { method, url } = req;
    const start = Date.now();

    res.on('finish', () => {
      const duration = Date.now() - start;
      console.log(`[${method}] ${url} - ${res.statusCode} (${duration}ms)`);
    });

    next();
  }
}


filepath: src/common/pagination/pagination.module.ts
file content:
import { Module } from '@nestjs/common';
import { PaginationService } from './pagination.service';

@Module({
  providers: [PaginationService],
  exports: [PaginationService],
})
export class PaginationModule {}


filepath: src/common/pagination/pagination.dto.ts
file content:
import { IsInt, Min, IsOptional, IsString, IsEnum } from 'class-validator';
import { Type } from 'class-transformer';
import { ApiPropertyOptional } from '@nestjs/swagger';

export enum SortOrder {
  ASC = 'ASC',
  DESC = 'DESC',
}

export class PaginationDto {
  @ApiPropertyOptional({ description: 'Page number (default: 1)', example: 1 })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  page?: number = 1;

  @ApiPropertyOptional({
    description: 'Items per page (default: 10)',
    example: 10,
  })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  limit?: number = 10;

  @ApiPropertyOptional({ description: 'Column to sort by', example: 'id' })
  @IsOptional()
  @IsString()
  sortBy?: string;

  @ApiPropertyOptional({
    description: 'Sorting order (ASC/DESC)',
    example: SortOrder.ASC,
  })
  @IsOptional()
  @IsEnum(SortOrder)
  order?: SortOrder = SortOrder.DESC;
}


filepath: src/common/pagination/pagination.service.ts
file content:
import { Injectable, BadRequestException } from '@nestjs/common';
import { SelectQueryBuilder, DataSource } from 'typeorm';
import { PaginationDto, SortOrder } from './pagination.dto';

@Injectable()
export class PaginationService {
  constructor(private readonly dataSource: DataSource) {} // âœ… Inject DataSource

  async paginate<T>(
    queryBuilder: SelectQueryBuilder<T>,
    paginationDto: PaginationDto,
    alias: string,
  ): Promise<{ data: T[]; total: number; page: number; limit: number }> {
    const { page, limit, sortBy, order } = paginationDto;
    const offset = (page - 1) * limit;

    // âœ… Get metadata and filter out relations (objects)
    const metadata = this.dataSource.getMetadata(queryBuilder.alias);
    const validColumns = metadata.columns
      .filter((col) => !col.relationMetadata) // âœ… Exclude object relations
      .map((col) => col.propertyName);

    // âœ… Validate `sortBy`
    if (sortBy && !validColumns.includes(sortBy)) {
      throw new BadRequestException(
        `Invalid sort field: "${sortBy}". Allowed fields: ${validColumns.join(', ')}`,
      );
    }

    // âœ… Apply sorting dynamically
    if (sortBy) {
      queryBuilder.orderBy(`${alias}.${sortBy}`, order);
    } else {
      queryBuilder.orderBy(`${alias}.id`, SortOrder.DESC);
    }

    const [data, total] = await queryBuilder
      .skip(offset)
      .take(limit)
      .getManyAndCount();

    return {
      data,
      total,
      page,
      limit,
    };
  }
}


filepath: src/common/entities/base-entity-soft-delete.ts
file content:
import { DeleteDateColumn } from 'typeorm';
import { ApiProperty } from '@nestjs/swagger';
import { BaseEntity } from './base.entity';
import { Exclude } from 'class-transformer';

export abstract class BaseEntitySoftDelete extends BaseEntity {
  @DeleteDateColumn({ nullable: true })
  @ApiProperty({
    description: 'Timestamp when entity was soft deleted',
    example: '2025-02-10T15:00:00.000Z',
  })
  @Exclude()
  deletedAt?: Date | null;
}


filepath: src/common/entities/base.entity.ts
file content:
import {
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryGeneratedColumn,
  BaseEntity as TypeOrmBaseEntity,
} from 'typeorm';
import { ApiProperty } from '@nestjs/swagger';

export abstract class BaseEntity extends TypeOrmBaseEntity  {
  @PrimaryGeneratedColumn()
  @ApiProperty({ description: 'Unique identifier', example: 1 })
  id: number;

  @CreateDateColumn({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })
  @ApiProperty({
    description: 'Timestamp when entity was created',
    example: '2025-02-02T20:00:00.000Z',
  })
  createdAt: Date;

  @UpdateDateColumn({
    type: 'timestamp',
    default: () => 'CURRENT_TIMESTAMP',
    onUpdate: 'CURRENT_TIMESTAMP',
  })
  @ApiProperty({
    description: 'Timestamp when entity was last updated',
    example: '2025-02-02T21:00:00.000Z',
  })
  updatedAt: Date;
}


filepath: src/users/users.service.ts
file content:
import { Injectable, NotFoundException } from '@nestjs/common';
import { Repository } from 'typeorm';
import { InjectRepository } from '@nestjs/typeorm';
import * as bcrypt from 'bcrypt';
import { User } from './entities/user.entity';
import { PaginationDto } from 'src/common/pagination/pagination.dto';
import { LoggerService } from 'src/logger/logger.service';
import { PaginationService } from 'src/common/pagination/pagination.service';

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User)
    private usersRepository: Repository<User>,
    private loggerService: LoggerService,
    private readonly paginationService: PaginationService,
  ) {}

  async findAll(paginationDto: PaginationDto) {
    this.loggerService.log(
      `Fetching all vehicles with pagination: ${JSON.stringify(paginationDto)}`,
    );

    const queryBuilder = this.usersRepository.createQueryBuilder('user');

    const result = await this.paginationService.paginate(
      queryBuilder,
      paginationDto,
      'user',
    );

    this.loggerService.log(`Fetched ${result.data.length} users`);
    return result;
  }

  async findOne(email: string): Promise<User | undefined> {
    return this.usersRepository.findOne({ where: { email } });
  }

  async create(email: string, password: string): Promise<User> {
    const user = this.usersRepository.create({ email, password });
    return this.usersRepository.save(user);
  }

  async validateUser(email: string, pass: string): Promise<User | null> {
    const user = await this.findOne(email);
    if (user && (await bcrypt.compare(pass, user.password))) {
      return user;
    }
    return null;
  }

  async delete(id: number): Promise<void> {
    const user = await this.usersRepository.findOne({ where: { id } });

    if (!user) {
      throw new NotFoundException(`User with id ${id} not found`);
    }

    await this.usersRepository.softDelete(id);
  }
}


filepath: src/users/users.module.ts
file content:
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UsersService } from './users.service';
import { User } from './entities/user.entity';
import { PaginationModule } from 'src/common/pagination/pagination.module';
import { LoggerModule } from 'src/logger/logger.module';

@Module({
  imports: [TypeOrmModule.forFeature([User]), PaginationModule, LoggerModule],
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}


filepath: src/users/entities/user.entity.ts
file content:
import { Entity, Column, BeforeInsert } from 'typeorm';
import * as bcrypt from 'bcrypt';
import { Exclude } from 'class-transformer';
import { RoleEnum } from 'src/auth/enum/role.enum';
import { ApiProperty } from '@nestjs/swagger';
import { BaseEntitySoftDelete } from 'src/common/entities/base-entity-soft-delete';

@Entity()
export class User extends BaseEntitySoftDelete {
  @Column({ unique: true })
  @ApiProperty({
    description: 'Email address of the user',
    example: 'email@gmail.com',
  })
  email: string;

  @Column()
  @Exclude()
  password: string;

  @Column('text', { array: true, default: [RoleEnum.USER] })
  @ApiProperty({
    description: 'List of user roles',
    example: [RoleEnum.USER],
  })
  roles: RoleEnum[];

  @BeforeInsert()
  async hashPassword() {
    this.password = await bcrypt.hash(this.password, 10);
  }
}


filepath: src/azure-storage/azure-storage.module.ts
file content:
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { AzureStorageService } from './azure-storage.service';

@Module({
  imports: [ConfigModule],
  providers: [AzureStorageService],
  exports: [AzureStorageService],
})
export class AzureStorageModule {}


filepath: src/azure-storage/azure-storage.service.ts
file content:
import { Injectable } from '@nestjs/common';
import { BlobServiceClient } from '@azure/storage-blob';
import { ConfigService } from '@nestjs/config';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class AzureStorageService {
  private blobServiceClient: BlobServiceClient;
  private containerName: string;

  constructor(private readonly configService: ConfigService) {
    const connectionString = this.configService.get<string>(
      'BLOB_STORAGE_CONNECTION_STRING',
    );
    this.containerName = this.configService.get<string>(
      'BLOB_STORAGE_VEHICLE_IMAGES_CONTAINER_NAME',
    );

    if (!connectionString || !this.containerName) {
      throw new Error('Azure Blob Storage configuration is missing.');
    }

    this.blobServiceClient =
      BlobServiceClient.fromConnectionString(connectionString);
  }

  async uploadFile(file: Express.Multer.File): Promise<string> {
    // âœ… Use `Express.Multer.File`
    const blobName = `${uuidv4()}-${file.originalname}`;
    const containerClient = this.blobServiceClient.getContainerClient(
      this.containerName,
    );
    const blockBlobClient = containerClient.getBlockBlobClient(blobName);

    await blockBlobClient.uploadData(file.buffer, {
      blobHTTPHeaders: { blobContentType: file.mimetype },
    });

    return blockBlobClient.url; // Return the URL of the uploaded file
  }
}


filepath: src/app.endpoints.http
file content:
### Register a new user
POST http://localhost:3000/auth/register
Content-Type: application/json

{
  "email": "test@example.com",
  "password": "password123"
}

### Login to get JWT token
POST http://localhost:3000/auth/login
Content-Type: application/json

{
  "email": "test@example.com",
  "password": "password123"
}

### Get user profile (Protected Route - Replace {{token}} with actual token)
GET http://localhost:3000/vehicles/2
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InRlc3RAZXhhbXBsZS5jb20iLCJzdWIiOjEsImlhdCI6MTczODQ1NTYxMiwiZXhwIjoxNzM4NDU5MjEyfQ.aQCjzbyxAkDyHkY5XPxA_rCR5pXDSIKvuqMZUBpwDiI


filepath: src/vehicles/dto/create-vehicle.dto.ts
file content:
import { ApiProperty } from '@nestjs/swagger';
import { IsString, IsInt, Min, Max } from 'class-validator';

export class CreateVehicleDto {
  @ApiProperty({ description: 'Make of the vehicle', example: 'Toyota' })
  @IsString()
  make: string;

  @ApiProperty({ description: 'Model of the vehicle', example: 'Corolla' })
  @IsString()
  model: string;

  @ApiProperty({ description: 'Year of manufacture', example: 2022 })
  @IsInt()
  @Min(1900)
  @Max(2100)
  year: number;

  @ApiProperty({
    description: 'Rental price per day in USD',
    example: 50,
  })
  @IsInt()
  @Min(1)
  rentalPricePerDay: number;
}


filepath: src/vehicles/dto/update-vehicle.dto.spec.ts
file content:
import { validate } from 'class-validator';
import { plainToInstance } from 'class-transformer';
import { UpdateVehicleDto } from './update-vehicle.dto';

describe('UpdateVehicleDto', () => {
  it('should pass validation if no fields are provided', async () => {
    const dto = {};

    const instance = plainToInstance(UpdateVehicleDto, dto);
    const errors = await validate(instance);

    expect(errors.length).toBe(0);
  });

  it('should pass validation with one field', async () => {
    const dto = { make: 'Tesla' };

    const instance = plainToInstance(UpdateVehicleDto, dto);
    const errors = await validate(instance);

    expect(errors.length).toBe(0);
  });

  it('should fail if a field is invalid type', async () => {
    const dto = { year: 'notANumber' };

    const instance = plainToInstance(UpdateVehicleDto, dto);
    const errors = await validate(instance);

    expect(errors).toEqual(
      expect.arrayContaining([
        expect.objectContaining({ property: 'year' }),
      ])
    );
  });

  it('should fail if a field is out of range', async () => {
    const dto = { year: 1700 };

    const instance = plainToInstance(UpdateVehicleDto, dto);
    const errors = await validate(instance);

    expect(errors).toEqual(
      expect.arrayContaining([
        expect.objectContaining({ property: 'year' }),
      ])
    );
  });

  it('should pass validation with all correct fields', async () => {
    const dto = {
      make: 'Ford',
      model: 'Focus',
      year: 2022,
      rentalPricePerDay: 60,
    };

    const instance = plainToInstance(UpdateVehicleDto, dto);
    const errors = await validate(instance);

    expect(errors.length).toBe(0);
  });
});


filepath: src/vehicles/dto/update-vehicle.dto.ts
file content:
import { PartialType } from '@nestjs/swagger';
import { CreateVehicleDto } from './create-vehicle.dto';

export class UpdateVehicleDto extends PartialType(CreateVehicleDto) {}


filepath: src/vehicles/dto/create-vehicle.dto.spec.ts
file content:
import { validate } from 'class-validator';
import { plainToInstance } from 'class-transformer';
import { CreateVehicleDto } from './create-vehicle.dto';

describe('CreateVehicleDto', () => {
  it('should pass validation with correct data', async () => {
    const dto = {
      make: 'Toyota',
      model: 'Corolla',
      year: 2022,
      rentalPricePerDay: 100,
    };

    const instance = plainToInstance(CreateVehicleDto, dto);
    const errors = await validate(instance);

    expect(errors.length).toBe(0);
  });

  it('should fail if make is missing', async () => {
    const dto = {
      model: 'Corolla',
      year: 2022,
      rentalPricePerDay: 100,
    };

    const instance = plainToInstance(CreateVehicleDto, dto);
    const errors = await validate(instance);

    expect(errors).toEqual(
      expect.arrayContaining([expect.objectContaining({ property: 'make' })]),
    );
  });

  it('should fail if year is not integer', async () => {
    const dto = {
      make: 'Toyota',
      model: 'Corolla',
      year: 'abcd', // invalid
      rentalPricePerDay: 100,
    };

    const instance = plainToInstance(CreateVehicleDto, dto);
    const errors = await validate(instance);

    expect(errors).toEqual(
      expect.arrayContaining([expect.objectContaining({ property: 'year' })]),
    );
  });

  it('should fail if year is out of range', async () => {
    const dto = {
      make: 'Toyota',
      model: 'Corolla',
      year: 1850, // too old
      rentalPricePerDay: 100,
    };

    const instance = plainToInstance(CreateVehicleDto, dto);
    const errors = await validate(instance);

    expect(errors).toEqual(
      expect.arrayContaining([expect.objectContaining({ property: 'year' })]),
    );
  });

  it('should fail if rentalPricePerDay is below minimum', async () => {
    const dto = {
      make: 'Toyota',
      model: 'Corolla',
      year: 2022,
      rentalPricePerDay: 0,
    };

    const instance = plainToInstance(CreateVehicleDto, dto);
    const errors = await validate(instance);

    expect(errors).toEqual(
      expect.arrayContaining([
        expect.objectContaining({ property: 'rentalPricePerDay' }),
      ]),
    );
  });
});


filepath: src/vehicles/vehicles.controller.ts
file content:
import {
  Controller,
  Get,
  Param,
  Post,
  Patch,
  Delete,
  Body,
  UploadedFile,
  UseGuards,
  UseInterceptors,
  Query,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiConsumes,
  ApiBody,
} from '@nestjs/swagger';
import { VehiclesService } from './vehicles.service';
import { CreateVehicleDto } from './dto/create-vehicle.dto';
import { UpdateVehicleDto } from './dto/update-vehicle.dto';
import { Vehicle } from './entities/vehicle.entity';
import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
import { FileInterceptor } from '@nestjs/platform-express';
import { PaginationDto } from 'src/common/pagination/pagination.dto';
import { RolesGuard } from 'src/auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { RoleEnum } from '../auth/enum/role.enum';

@ApiTags('Vehicles')
@Controller('vehicles')
export class VehiclesController {
  constructor(private readonly vehiclesService: VehiclesService) {}

  @Post()
  @ApiOperation({ summary: 'Create a new vehicle' })
  @ApiResponse({
    status: 201,
    description: 'Vehicle created successfully.',
    type: Vehicle,
  })
  async create(@Body() createVehicleDto: CreateVehicleDto) {
    return this.vehiclesService.create(createVehicleDto);
  }

  @Get()
  @ApiOperation({ summary: 'Retrieve all vehicles with images' })
  @ApiResponse({
    status: 200,
    description: 'List of vehicles retrieved.',
    type: [Vehicle],
  })
  async findAll(@Query() paginationDto: PaginationDto) {
    return this.vehiclesService.findAll(paginationDto);
  }

  @UseGuards(JwtAuthGuard)
  @Get(':id')
  @ApiOperation({ summary: 'Retrieve a vehicle by ID with its images' })
  @ApiResponse({
    status: 200,
    description: 'Vehicle retrieved successfully.',
    type: Vehicle,
  })
  @ApiResponse({ status: 404, description: 'Vehicle not found.' })
  async findOne(@Param('id') id: number) {
    return this.vehiclesService.findOne(id);
  }

  @Patch(':id')
  @ApiOperation({ summary: 'Update a vehicle by ID' })
  @ApiResponse({
    status: 200,
    description: 'Vehicle updated successfully.',
    type: Vehicle,
  })
  async update(
    @Param('id') id: number,
    @Body() updateVehicleDto: UpdateVehicleDto,
  ) {
    return this.vehiclesService.update(id, updateVehicleDto);
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Remove a vehicle by ID' })
  @ApiResponse({
    status: 200,
    description: 'Vehicle removed successfully.',
  })
  async remove(@Param('id') id: number) {
    return this.vehiclesService.delete(id);
  }

  @Post(':id/upload-image')
  @UseInterceptors(FileInterceptor('file'))
  @ApiConsumes('multipart/form-data') // âœ… Specify form-data content type
  @ApiOperation({ summary: 'Upload an image for a vehicle' })
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        file: {
          type: 'string',
          format: 'binary', // âœ… Needed to show file upload field in Swagger
        },
      },
    },
  })
  @ApiResponse({ status: 201, description: 'Image uploaded successfully.' })
  async uploadImage(
    @Param('id') id: number,
    @UploadedFile() file: Express.Multer.File,
  ) {
    return this.vehiclesService.uploadImage(id, file);
  }
}


filepath: src/vehicles/vehicles.module.ts
file content:
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { VehiclesService } from './vehicles.service';
import { VehiclesController } from './vehicles.controller';
import { Vehicle } from './entities/vehicle.entity';
import { VehicleImage } from './entities/vehicle-image.entity';
import { AzureStorageModule } from '../azure-storage/azure-storage.module';
import { PaginationModule } from 'src/common/pagination/pagination.module';
import { LoggerModule } from 'src/logger/logger.module';
import { AuthModule } from 'src/auth/auth.module';

@Module({
  imports: [
    TypeOrmModule.forFeature([Vehicle, VehicleImage]),
    AzureStorageModule,
    PaginationModule,
    LoggerModule,
  ],
  controllers: [VehiclesController],
  providers: [VehiclesService],
})
export class VehiclesModule {}


filepath: src/vehicles/vehicles.service.spec.ts
file content:
import { Test, TestingModule } from '@nestjs/testing';
import { VehiclesService } from './vehicles.service';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Vehicle } from './entities/vehicle.entity';
import { VehicleImage } from './entities/vehicle-image.entity';
import { AzureStorageService } from '../azure-storage/azure-storage.service';
import { PaginationService } from 'src/common/pagination/pagination.service';
import { LoggerService } from 'src/logger/logger.service';

const mockVehicleRepo = {
  create: jest.fn(),
  save: jest.fn(),
  findOne: jest.fn(),
  remove: jest.fn(),
  createQueryBuilder: jest.fn(),
};
const mockVehicleImageRepo = {
  create: jest.fn(),
  save: jest.fn(),
};
const mockAzureStorageService = { uploadFile: jest.fn() };
const mockPaginationService = { paginate: jest.fn() };
const mockLoggerService = { log: jest.fn(), warn: jest.fn() };

describe('VehiclesService', () => {
  let service: VehiclesService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        VehiclesService,
        { provide: getRepositoryToken(Vehicle), useValue: mockVehicleRepo },
        {
          provide: getRepositoryToken(VehicleImage),
          useValue: mockVehicleImageRepo,
        },
        { provide: AzureStorageService, useValue: mockAzureStorageService },
        { provide: PaginationService, useValue: mockPaginationService },
        { provide: LoggerService, useValue: mockLoggerService },
      ],
    }).compile();

    service = module.get<VehiclesService>(VehiclesService);

    // Reset mocks for isolation between tests
    Object.values(mockVehicleRepo).forEach(
      (fn) => fn.mockReset && fn.mockReset(),
    );
    Object.values(mockVehicleImageRepo).forEach(
      (fn) => fn.mockReset && fn.mockReset(),
    );
    mockAzureStorageService.uploadFile.mockReset();
    mockPaginationService.paginate.mockReset();
    mockLoggerService.log.mockReset();
    mockLoggerService.warn.mockReset();
  });

  it('should create a vehicle', async () => {
    const dto = {
      make: 'Tesla',
      model: 'X',
      year: 2020,
      rentalPricePerDay: 100,
    };
    const entity = { ...dto, id: 1 };
    mockVehicleRepo.create.mockReturnValue(dto);
    mockVehicleRepo.save.mockResolvedValue(entity);

    const result = await service.create(dto as any);
    expect(result).toEqual(entity);
    expect(mockVehicleRepo.create).toBeCalledWith(dto);
    expect(mockVehicleRepo.save).toBeCalledWith(dto);
  });

  it('should get a vehicle by id', async () => {
    const vehicle = { id: 1, make: 'Tesla', images: [] };
    mockVehicleRepo.findOne.mockResolvedValue(vehicle);

    const result = await service.findOne(1);
    expect(result).toBe(vehicle);
    expect(mockVehicleRepo.findOne).toBeCalledWith({
      where: { id: 1 },
      relations: ['images'],
    });
  });

  it('should throw NotFoundException if vehicle not found', async () => {
    mockVehicleRepo.findOne.mockResolvedValue(undefined);
    await expect(service.findOne(999)).rejects.toThrow(
      'Vehicle with ID 999 not found',
    );
  });

  it('should update a vehicle', async () => {
    const vehicle = {
      id: 1,
      make: 'Tesla',
      model: 'X',
      year: 2020,
      rentalPricePerDay: 100,
    };
    mockVehicleRepo.findOne.mockResolvedValue(vehicle);
    mockVehicleRepo.save.mockResolvedValue({
      ...vehicle,
      rentalPricePerDay: 120,
    });

    const result = await service.update(1, { rentalPricePerDay: 120 } as any);
    expect(result.rentalPricePerDay).toBe(120);
  });

  it('should throw NotFoundException when updating non-existing vehicle', async () => {
    mockVehicleRepo.findOne.mockResolvedValue(undefined);

    await expect(service.update(999, { make: 'Nowa' } as any)).rejects.toThrow(
      'Vehicle with ID 999 not found',
    );
  });

  it('should delete a vehicle', async () => {
    const vehicle = { id: 1, make: 'Tesla' };
    mockVehicleRepo.findOne.mockResolvedValue(vehicle);
    mockVehicleRepo.remove.mockResolvedValue(undefined);

    await service.delete(1);
    expect(mockVehicleRepo.remove).toBeCalledWith(vehicle);
  });

  it('should throw NotFoundException when deleting non-existing vehicle', async () => {
    mockVehicleRepo.findOne.mockResolvedValue(undefined);

    await expect(service.delete(999)).rejects.toThrow(
      'Vehicle with ID 999 not found',
    );
  });

  it('should upload image for a vehicle', async () => {
    const file = {
      originalname: 'img.jpg',
      buffer: Buffer.from(''),
      mimetype: 'image/jpeg',
    } as any;
    const vehicle = { id: 1, images: [] };
    mockVehicleRepo.findOne.mockResolvedValue(vehicle);
    mockAzureStorageService.uploadFile.mockResolvedValue('url.jpg');
    const image = { id: 1, vehicle, imageUrl: 'url.jpg' };
    mockVehicleImageRepo.create.mockReturnValue({
      vehicle,
      imageUrl: 'url.jpg',
    });
    mockVehicleImageRepo.save.mockResolvedValue(image);

    const result = await service.uploadImage(1, file);
    expect(result).toEqual(image);
    expect(mockAzureStorageService.uploadFile).toBeCalledWith(file);
    expect(mockVehicleImageRepo.create).toBeCalledWith({
      vehicle,
      imageUrl: 'url.jpg',
    });
    expect(mockVehicleImageRepo.save).toBeCalled();
  });

  it('should throw NotFoundException when uploading image for non-existing vehicle', async () => {
    mockVehicleRepo.findOne.mockResolvedValue(undefined);

    await expect(service.uploadImage(123, {} as any)).rejects.toThrow(
      /Vehicle with ID 123 not found/,
    );
  });

  it('should fetch all vehicles with pagination', async () => {
    const paginationDto = { page: 1, limit: 10 } as any;
    const paginatedResult = {
      data: [
        {
          id: 1,
          make: 'Tesla',
          model: 'S',
          year: 2020,
          rentalPricePerDay: 100,
          images: [],
        },
      ],
      total: 1,
      page: 1,
      limit: 10,
    };
    // Udajemy, Å¼e queryBuilder zwraca siÄ™ poprawnie, a paginate woÅ‚a paginatedResult
    mockVehicleRepo.createQueryBuilder.mockReturnValue({
      leftJoinAndSelect: jest.fn().mockReturnThis(),
      skip: jest.fn().mockReturnThis(),
      take: jest.fn().mockReturnThis(),
      getManyAndCount: jest
        .fn()
        .mockResolvedValue([paginatedResult.data, paginatedResult.total]),
      orderBy: jest.fn().mockReturnThis(),
    });
    mockPaginationService.paginate.mockResolvedValue(paginatedResult);

    const result = await service.findAll(paginationDto);
    expect(result).toEqual(paginatedResult);
    expect(mockPaginationService.paginate).toBeCalled();
  });

  it('should call loggerService.log when creating vehicle', async () => {
    const dto = {
      make: 'BMW',
      model: 'M3',
      year: 2021,
      rentalPricePerDay: 200,
    };
    mockVehicleRepo.create.mockReturnValue(dto);
    mockVehicleRepo.save.mockResolvedValue({ ...dto, id: 2 });

    await service.create(dto as any);
    expect(mockLoggerService.log).toHaveBeenCalled();
  });
});


filepath: src/vehicles/vehicles.endpoints.http
file content:
### 1ï¸âƒ£ Create a Vehicle
POST http://localhost:3000/vehicles
Content-Type: application/json

{
  "make": "Tesla",
  "model": "Model S",
  "year": 2023,
  "rentalPricePerDay": 150
}

### 2ï¸âƒ£ Get All Vehicles
GET http://localhost:3000/vehicles

### 3ï¸âƒ£ Get a Single Vehicle by ID
GET http://localhost:3000/vehicles/1
# Replace `1` with the actual vehicle ID

### 4ï¸âƒ£ Update a Vehicle by ID
PATCH http://localhost:3000/vehicles/2
Content-Type: application/json

{
  "rentalPricePerDay": 120
}
# Replace `1` with the actual vehicle ID

### 5ï¸âƒ£ Delete a Vehicle by ID
DELETE http://localhost:3000/vehicles/1
# Replace `1` with the actual vehicle ID


filepath: src/vehicles/vehicles.service.ts
file content:
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Vehicle } from './entities/vehicle.entity';
import { CreateVehicleDto } from './dto/create-vehicle.dto';
import { UpdateVehicleDto } from './dto/update-vehicle.dto';
import { VehicleImage } from './entities/vehicle-image.entity';
import { AzureStorageService } from '../azure-storage/azure-storage.service';
import { PaginationService } from 'src/common/pagination/pagination.service';
import { PaginationDto } from 'src/common/pagination/pagination.dto';
import { LoggerService } from 'src/logger/logger.service';

@Injectable()
export class VehiclesService {
  constructor(
    @InjectRepository(Vehicle)
    private readonly vehicleRepository: Repository<Vehicle>,
    @InjectRepository(VehicleImage)
    private readonly vehicleImageRepository: Repository<VehicleImage>,
    private readonly azureStorageService: AzureStorageService,
    private readonly paginationService: PaginationService,
    private readonly loggerService: LoggerService,
  ) {}

  async create(createVehicleDto: CreateVehicleDto): Promise<Vehicle> {
    this.loggerService.log(
      `Creating vehicle: ${JSON.stringify(createVehicleDto)}`,
    );

    const vehicle = this.vehicleRepository.create(createVehicleDto);
    const savedVehicle = await this.vehicleRepository.save(vehicle);

    this.loggerService.log(`Vehicle created with ID: ${savedVehicle.id}`);
    return savedVehicle;
  }

  async findAll(paginationDto: PaginationDto) {
    this.loggerService.log(
      `Fetching all vehicles with pagination: ${JSON.stringify(paginationDto)}`,
    );

    const queryBuilder = this.vehicleRepository
      .createQueryBuilder('vehicle')
      .leftJoinAndSelect('vehicle.images', 'images');

    const result = await this.paginationService.paginate(
      queryBuilder,
      paginationDto,
      'vehicle',
    );

    this.loggerService.log(`Fetched ${result.data.length} vehicles`);
    return result;
  }

  async findOne(id: number): Promise<Vehicle> {
    this.loggerService.log(`Fetching vehicle with ID: ${id}`);

    const vehicle = await this.vehicleRepository.findOne({
      where: { id },
      relations: ['images'],
    });

    if (!vehicle) {
      this.loggerService.warn(`Vehicle with ID ${id} not found`);
      throw new NotFoundException(`Vehicle with ID ${id} not found`);
    }

    this.loggerService.log(`Vehicle found: ${JSON.stringify(vehicle)}`);
    return vehicle;
  }

  async update(
    id: number,
    updateVehicleDto: UpdateVehicleDto,
  ): Promise<Vehicle> {
    this.loggerService.log(
      `Updating vehicle ID ${id} with data: ${JSON.stringify(updateVehicleDto)}`,
    );

    const vehicle = await this.findOne(id);
    Object.assign(vehicle, updateVehicleDto);
    const updatedVehicle = await this.vehicleRepository.save(vehicle);

    this.loggerService.log(`Vehicle ID ${id} updated successfully`);
    return updatedVehicle;
  }

  async delete(id: number): Promise<void> {
    this.loggerService.warn(`Deleting vehicle with ID: ${id}`);

    const vehicle = await this.findOne(id);
    await this.vehicleRepository.remove(vehicle);

    this.loggerService.warn(`Vehicle with ID ${id} deleted`);
  }

  async uploadImage(
    vehicleId: number,
    file: Express.Multer.File,
  ): Promise<VehicleImage> {
    this.loggerService.log(`Uploading image for vehicle ID: ${vehicleId}`);

    const vehicle = await this.findOne(vehicleId);
    if (!vehicle) {
      this.loggerService.warn(
        `Vehicle ID ${vehicleId} not found for image upload`,
      );
      throw new NotFoundException('Vehicle not found');
    }

    const imageUrl = await this.azureStorageService.uploadFile(file);
    const vehicleImage = this.vehicleImageRepository.create({
      vehicle,
      imageUrl,
    });

    const savedImage = await this.vehicleImageRepository.save(vehicleImage);
    this.loggerService.log(
      `Image uploaded for vehicle ID ${vehicleId}: ${imageUrl}`,
    );

    return savedImage;
  }
}


filepath: src/vehicles/entities/vehicle.entity.ts
file content:
import { Entity, Column, OneToMany } from 'typeorm';
import { ApiProperty } from '@nestjs/swagger';
import { VehicleImage } from './vehicle-image.entity';
import { BaseEntity } from 'src/common/entities/base.entity';

@Entity()
export class Vehicle extends BaseEntity {
  @Column()
  @ApiProperty({ description: 'Make of the vehicle', example: 'Toyota' })
  make: string;

  @Column()
  @ApiProperty({ description: 'Model of the vehicle', example: 'Corolla' })
  model: string;

  @Column()
  @ApiProperty({ description: 'Year of manufacture', example: 2022 })
  year: number;

  @Column()
  @ApiProperty({
    description: 'Rental price per day in USD',
    example: 50,
  })
  rentalPricePerDay: number;

  @OneToMany(() => VehicleImage, (vehicleImage) => vehicleImage.vehicle, {
    cascade: true,
  })
  @ApiProperty({
    description: 'List of vehicle images',
    type: () => [VehicleImage],
  }) // âœ… FIX: Lazy resolver
  images: VehicleImage[];
}


filepath: src/vehicles/entities/vehicle-image.entity.ts
file content:
import { Entity, Column, ManyToOne } from 'typeorm';
import { ApiProperty } from '@nestjs/swagger';
import { Vehicle } from './vehicle.entity';
import { BaseEntity } from 'src/common/entities/base.entity';

@Entity()
export class VehicleImage extends BaseEntity {
  @Column()
  @ApiProperty({
    description: 'URL of the vehicle image',
    example: 'https://example.com/car.jpg',
  })
  imageUrl: string;

  @ManyToOne(() => Vehicle, (vehicle) => vehicle.images, {
    onDelete: 'CASCADE',
  })
  @ApiProperty({ description: 'Associated vehicle', type: () => Vehicle }) // âœ… FIX: Lazy resolver
  vehicle: Vehicle;
}


filepath: src/vehicles/vehicles.controller.spec.ts
file content:
import { Test, TestingModule } from '@nestjs/testing';
import { VehiclesController } from './vehicles.controller';
import { VehiclesService } from './vehicles.service';

const mockVehiclesService = {
  create: jest.fn(),
  findAll: jest.fn(),
  findOne: jest.fn(),
  update: jest.fn(),
  delete: jest.fn(),
  uploadImage: jest.fn(),
};

describe('VehiclesController', () => {
  let controller: VehiclesController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [VehiclesController],
      providers: [{ provide: VehiclesService, useValue: mockVehiclesService }],
    }).compile();

    controller = module.get<VehiclesController>(VehiclesController);

    // Resetujemy mocki po kaÅ¼dym teÅ›cie
    Object.values(mockVehiclesService).forEach(
      (fn) => fn.mockReset && fn.mockReset(),
    );
  });

  it('should create a vehicle', async () => {
    const dto = {
      make: 'Tesla',
      model: 'Y',
      year: 2024,
      rentalPricePerDay: 120,
    };
    const vehicle = { ...dto, id: 1 };
    mockVehiclesService.create.mockResolvedValue(vehicle);

    const result = await controller.create(dto as any);
    expect(result).toEqual(vehicle);
    expect(mockVehiclesService.create).toHaveBeenCalledWith(dto);
  });

  it('should return all vehicles', async () => {
    const vehicles = [{ id: 1 }, { id: 2 }] as any[];
    mockVehiclesService.findAll.mockResolvedValue(vehicles);

    const result = await controller.findAll({} as any);
    expect(result).toEqual(vehicles);
    expect(mockVehiclesService.findAll).toHaveBeenCalledWith({});
  });

  it('should return a single vehicle by id', async () => {
    const vehicle = { id: 1, make: 'Tesla' };
    mockVehiclesService.findOne.mockResolvedValue(vehicle);

    const result = await controller.findOne(1);
    expect(result).toEqual(vehicle);
    expect(mockVehiclesService.findOne).toHaveBeenCalledWith(1);
  });

  it('should update a vehicle', async () => {
    const dto = { rentalPricePerDay: 150 };
    const updated = { id: 1, make: 'Tesla', rentalPricePerDay: 150 };
    mockVehiclesService.update.mockResolvedValue(updated);

    const result = await controller.update(1, dto as any);
    expect(result).toEqual(updated);
    expect(mockVehiclesService.update).toHaveBeenCalledWith(1, dto);
  });

  it('should delete a vehicle', async () => {
    mockVehiclesService.delete.mockResolvedValue(undefined);
    await controller.remove(1);
    expect(mockVehiclesService.delete).toHaveBeenCalledWith(1);
  });

  it('should upload image for a vehicle', async () => {
    const image = { id: 1, vehicle: { id: 1 }, imageUrl: 'url.jpg' };
    const file = { originalname: 'img.jpg', buffer: Buffer.from('') } as any;
    mockVehiclesService.uploadImage.mockResolvedValue(image);

    const result = await controller.uploadImage(1, file);
    expect(result).toEqual(image);
    expect(mockVehiclesService.uploadImage).toHaveBeenCalledWith(1, file);
  });
});


filepath: src/app.controller.ts
file content:
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}


